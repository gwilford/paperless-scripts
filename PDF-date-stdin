#!/usr/bin/perl -w

# Take text on STDIN and a source filename as 1st argument
# - search for appropriate date string in text
# - set the source file modification time to date (if found)
# - print out date string for use as name of file/record

use Date::Extract;

my $parser = Date::Extract->new();
my $now = time();
my $today = DateTime->now();
my $year = 52*7*24*3600;
my @monthy = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
my @dates;

# Range of dates that are deemed allowable ($past > date > $future)
#my $future = $year;
my $future = 30*24*3600;
my $past = 30*$year;

# initial part of document to check first
my $initial_size = 500;

my $filename = $ARGV[0] || die "no filename supplied";

# debgugging
open (LOG, ">>/Users/gwilford/dateparse.log") or die "cannot log";
print LOG "$filename\n";

# Process the text
print process() . "\n";

print LOG "\n";
close LOG;

# re-form parsed dates in Date::Extract friendly format including y2k fix
sub dform {
	my ($d, $m, $y) = @_;
	print LOG "$y/$m/$d: ";

	# set to 1st of month if no day in date
	if (!$d) {
		$d = 1;
	}
	# lookup short month name if digit passed
	if ($m =~ m/\d+/) {
		$m = $monthy[$m-1];
	}

	# ensure 4-digit year
	if ($y < 20) {
		$y += 2000;
	} elsif ($y < 1900) {
		$y += 1900;
	}

	# for Date::Extract 
	my $s = sprintf(" %s %d, %4d", $m, $d, $y);
	print LOG $s . "\n";
	push @dates, localtime(0, 0, 0, $d, $m, $y);
	return ('');
}

	
sub process {
	my ($dt, $textlen, $line);
	my $text = "";

	while ($line = <STDIN>) {
		$text .= $line;
	}
	return "no text" unless ($text);

	print LOG $text;

	# Pre-process various Date::Extract unfriendly date formats
	#
	# separators can be '-|/|.' or whitespace 
	$sep = '-|\/|\.|\s+';
	# day can be:
	# - single digit with or without leading zero
	# - double digit
	# - suffixed (eg 1st, 15th, 22nd)
	# - missing
	$day = '0?[1-9]|[12][0-9]|3[01]';
	$suffix = 'st|nd|rd|th';
	# month can be full or short name
	$month = 'jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec';
	$month .= '|1[012]|0?[1-9]';
	# year can be 2 or 4 digits
	$yr = '(19|20)\d{2}?';
	$text =~ s/($day)?($suffix)?($sep)?($month)\w*($sep)?($yr)/dform($1, $4, $6)/eig;

	# lose now/today/tomorrow
	$text =~ s/now|today|tomorrow//ig;

	# lose days of week
	$text =~ s/(mon|tues?|wed(nes)?|thu(rs)?|fri|sat(ur)?|sun)(day)?//ig;

	# look for first "date*" string
	if (substr($text, 0, $initial_size) =~ /date:?\s+(.*)/is) {
		$dt = $parser->extract(substr($1, 0, 50));
	}

	# check initial part of document text
	if (!$dt) {
		$dt = $parser->extract(substr($text, 0, $initial_size));
	}

	# check remaining parts of document
	if (!$dt && length($text) > $initial_size) {
		$dt = $parser->extract(substr($text, $initial_size-30));	
	}
	return "no date" unless $dt;

	# sanity-check the date found
	if ($dt->epoch > $now + $future ||
	    $dt->epoch < $now - $past) {
		return "no date";
	# don't allow 'today'
	#} elsif ($today->ymd eq $dt->ymd) {
	#	return "no date";
	}
		
	# date is good!
	utime($dt->epoch, $dt->epoch, $filename);
	return $dt->ymd;
}
