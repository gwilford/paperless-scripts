#!/usr/bin/perl -w

# Take text on STDIN and a source filename as 1st argument
# - search for appropriate date string in text
# - set the source file modification time to date (if found)
# - print out date string for use as name of file/record

use Time::Local;
use POSIX qw(strftime);

my $now = time();
my %monthy = ( jan => 0, feb => 1, mar => 2, apr => 3, may => 4, jun => 5, jul => 6, 
	       aug => 7, sep => 8, oct => 9, nov => 10, dec => 11);

# Range of dates that are deemed allowable ($past > date > $future)
my $year = 52*7*24*3600;
my $future = 30*24*3600;
my $past = 30*$year;

my $filename = $ARGV[0] || die "no filename supplied";

# debgugging
open (LOG, ">>/Users/gwilford/dateparse.log") or die "cannot log";
print LOG "$filename\n";

# Process the text
print process() . "\n";

print LOG "\n";
close LOG;

# parse dates and return seconds since epoch
sub dform {
	my ($d, $mstr, $mdig, $y) = @_;

	# set to 1st of month if no day in date
	$d = 1 unless ($d);

	# convert month number or short-name to timelocal $mon
	if ($mdig) {
		$m = $mdig-1;
	} else {
		$m = $monthy{lc(substr($mstr, 0, 3))};
	}

	# ensure 4-digit year
	if ($y < 20) {
		$y += 2000;
	} elsif ($y < 1900) {
		$y += 1900;
	}

	return timelocal(0, 0, 0, $d, $m, $y);
}

# parse text, change file timestamp and return date for filename
sub process {
	# content passed by DEVONthink/applescript has CR line-endings instead of LF
	local $/ = "\r";
	while (my $text = <STDIN>) {
		print LOG $text;
	
		# separators can be '-|/|.' or whitespace 
		# FIXME: separators should be consistent using backrefs but need to handle
		#        single or multi-whitespace
		my $sep = '-|\/|\.|\s+';
		# day can be:
		# - single digit with or without leading zero
		# - double digit
		# - suffixed (eg 1st, 15th, 22nd)
		# - missing
		my $day = '0?[1-9]|[12][0-9]|3[01]';
		my $suffix = 'st|nd|rd|th';
		# month can be full or short name
		my $mstr = 'jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec';
		my $mdig = '1[012]|0?[1-9]';
		# year can be 2 or 4 digits but must not be followed by a % or other digit
		my $yr = '(19|20)?\d{2}?(?![%\d])';
	
		# FIXME: February 27, 2000
		# FIXME: need to handle $mstr and $mdig differently
		#while ($text =~ /(($day)($suffix)?($sep))?(($mstr)[a-z]*,?|\b($mdig))($sep)($yr)(?![%\d])/ig) {
		while ($text =~ /(($day)($suffix)?($sep))?(($mstr)[a-z]*,?)()($sep)($yr)/ig ||
		       $text =~ /(($day)($suffix)?($sep))()()($mdig)(\4)($yr)/ig ) {
			# catch any specific false positives
			#next if ($& =~ /^\d+\.\d+$/);

			my $epoch = dform($2, $6, $7, $9);
			print LOG "\n** $& = " . localtime($epoch) . " **\n";

			# catch dates outside of acceptable range
			next if ($epoch > $now + $future || 
				 $epoch < $now - $past);

			# set file timestamp
			utime($epoch, $epoch, $filename);
			if ($1) {
				$name = strftime("%Y-%m-%d", localtime($epoch));
			} else {
				# no day number
				$name = strftime("%Y-%m", localtime($epoch));
			}
			print LOG "title = $name\n";
			return $name;
		}
		#return "no date";
	}		
	return "no date";
}
