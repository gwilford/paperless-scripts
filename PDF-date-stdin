#!/usr/bin/perl -w

# Take text on STDIN and a source filename as 1st argument
# - search for appropriate date string in text
# - set the source file modification time to date (if found)
# - print out date string for use as name of file/record

use Time::Local;
use POSIX qw(strftime);

my $now = time();
my %monthy = ( jan => 0, feb => 1, mar => 2, apr => 3, may => 4, jun => 5, jul => 6, 
	       aug => 7, sep => 8, oct => 9, nov => 10, dec => 11);
my @dates;

# Range of dates that are deemed allowable ($past > date > $future)
my $year = 52*7*24*3600;
my $future = 30*24*3600;
my $past = 30*$year;

my $filename = $ARGV[0] || die "no filename supplied";

# debgugging
open (LOG, ">>/Users/gwilford/dateparse.log") or die "cannot log";
print LOG "$filename\n";

# Process the text
print process() . "\n";

print LOG "\n";
close LOG;

# re-form parsed dates in Date::Extract friendly format including y2k fix
sub dform {
	my ($d, $m, $y) = @_;
	print LOG "$y/$m/$d: ";

	# set to 1st of month if no day in date
	if (!$d) {
		$d = 1;
	}
	# convert month number or short-name to timelocal $mon
	if ($m =~ m/\d+/) {
		$m--;
	} else {
		$m = $monthy{lc($m)};
	}

	# ensure 4-digit year
	if ($y < 20) {
		$y += 2000;
	} elsif ($y < 1900) {
		$y += 1900;
	}

	# for Date::Extract 
	my $s = sprintf(" %d %d, %4d", $m, $d, $y);
	print LOG $s . "\n";
	push @dates, timelocal(0, 0, 0, $d, $m, $y);
	return ('');
}

	
sub process {
	my ($dt, $textlen, $line);
	my $text = "";

	while ($line = <STDIN>) {
		$text .= $line;
	}
	# Should never happen as this case is caught by the applescript
	return "no text" unless ($text);

	print LOG $text;

	# Pre-process various Date::Extract unfriendly date formats
	#
	# separators can be '-|/|.' or whitespace 
	$sep = '-|\/|\.|\s+';
	# day can be:
	# - single digit with or without leading zero
	# - double digit
	# - suffixed (eg 1st, 15th, 22nd)
	# - missing
	$day = '0?[1-9]|[12][0-9]|3[01]';
	$suffix = 'st|nd|rd|th';
	# month can be full or short name
	$month = 'jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec';
	$month .= '|1[012]|0?[1-9]';
	# year can be 2 or 4 digits
	$yr = '(19|20)\d{2}?';
	$text =~ s/($day)?($suffix)?($sep)?($month)\w*($sep)?($yr)/dform($1, $4, $6)/eig;

	while (my $epoch = shift @dates) {
		print LOG "$epoch\n";
		next if ($epoch > $now + $future || 
			 $epoch < $now - $past);
		# date is good!
		utime($epoch, $epoch, $filename);
		return strftime("%Y-%m-%d", localtime($epoch));
	}
	return "no date";
		
}
