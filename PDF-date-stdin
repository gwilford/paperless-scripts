#!/usr/bin/perl -w

# Take text on STDIN and a source filename as 1st argument
# - search for appropriate date string in text
# - set the source file modification time to date (if found)
# - print out date string for use as name of file/record

use Time::Local;
use POSIX qw(strftime);
use strict;
use Getopt::Std;

my $now = time();
my %monthy = ( jan => 0, feb => 1, mar => 2, apr => 3, may => 4, jun => 5, jul => 6, 
	       aug => 7, sep => 8, oct => 9, nov => 10, dec => 11);

# Range of dates that are deemed allowable ($past > date > $future)
my $year = 52*7*24*3600;
my $future = 30*24*3600;
my $past = 30*$year;

sub usage {
	die "Usage: $0 [ -t ] [ -c ] [ -L logfile ] [ filename ]\n" .
	    "       -t: test mode - continue after first match\n" .
	    "       -c: CR instead of LF\n";
}

our($opt_t, $opt_L, $opt_c);
getopts('tcL:') || usage();

my $filename = $ARGV[0];

# debgugging
if ($opt_L) {
	open (LOG, ">>$opt_L") or die "cannot log";
}

printlog("$filename\n") if ($filename);

# Process the text
print process() . "\n";

printlog("\n");
close LOG if ($opt_L);

sub testmatch {
	my ($text, $match) = @_;
	if ($text =~ /\|([^|]+)\|/) {
		my $expected = $1;
		if ($match eq $expected) {
			print "PASS: $match: $text";
		} else {
			print "FAIL: $match != $expected: $text";
		}
	} else {
		print "BAD : no expected answer in test line";
	}
}

sub printlog {
	return unless ($opt_L);
	print LOG $_[0];
}

# parse dates and return seconds since epoch
sub dform {
	my ($day, $mstr, $mdig, $altday, $yr) = @_;
	my $mon;
	
	# for test purposes
	if (!$yr) {
		return timelocal(0, 0, 0, 1, 1, 0);
	}

	# set to 1st of month if no day in date
	if ($altday) {
		$day = $altday;
	} elsif (!$day) {
		$day = 1;
	}

	# convert month number or short-name to timelocal $mon
	if ($mdig) {
		$mon = $mdig-1;
	} else {
		$mon = $monthy{lc(substr($mstr, 0, 3))};
	}

	# ensure 4-digit year
	if ($yr < 20) {
		$yr += 2000;
	} elsif ($yr < 1900) {
		$yr += 1900;
	}

	return timelocal(0, 0, 0, $day, $mon, $yr);
}

# parse text, change file timestamp and return date for filename
sub process {
	# content passed by DEVONthink/applescript has CR line-endings instead of LF
	local $/ = "\r" if ($opt_c);
	while (my $text = <STDIN>) {
		printlog($text);
		# separators can be '-|/|.' or whitespace 
		# FIXME: separators should be consistent using backrefs but need to handle
		#        single or multi-whitespace
		my $sep = '-|\/|\.|\s+';
		# day can be:
		# - single digit with or without leading zero
		# - double digit
		# - suffixed (eg 1st, 15th, 22nd)
		# - missing
		my $day = '0?[1-9]|[12][0-9]|3[01]';
		my $suffix = 'st|nd|rd|th';
		# month can be full or short name
		my $mstr = 'jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may' .
			   '|june?|july?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?' .
			   '|nov(?:ember)?|dec(?:ember)?';
		my $mdig = '1[012]|0?[1-9]';
		# year can be 2 or 4 digits but must not be followed by a % or digit
		my $yr = '(19|20)?\d{2}?(?![%\d])';
	
		# NB. extended patterns don't count as $<num>
		# day or mdig cannot be prefixed by digits
		# FIXME: need to handle $mstr and $mdig differently
		my $pattern = '(?<![\w\/Â£-])' .
			      "(?:($day)(?:$suffix)?(?:$sep))?" .
			      "(?:($mstr),?|($mdig))(?:$sep)" .
			      "(?:($day)(?:$suffix)?,(?:$sep))?($yr)" .
			      '(?![\w\/%-])';

		while ($text =~ /$pattern/ig || $opt_t) {
			# catch any specific false positives
			next if ($& && $& =~ /^\d+\.\d+$/);

			my $epoch = dform($1, $2, $3, $4, $5);
			printlog("\n** $& = " . localtime($epoch) . "\n") if ($&);

			# catch dates outside of acceptable range
			next if ($epoch > $now + $future || 
				 $epoch < $now - $past);

			# set file timestamp
			utime($epoch, $epoch, $filename) if ($filename);
			my $name;
			if (!$5) {
				# for test only
				$name = "no date";
			} elsif ($1) {
				$name = strftime("%Y-%m-%d", localtime($epoch));
			} else {
				# no day number
				$name = strftime("%Y-%m", localtime($epoch));
			}
			printlog("** title = $name\n");

			# keep processing if in test mode
			if ($opt_t) {
				testmatch($text, $name);
				last;
			}
			return $name;
		}
	}		
	return "no date";
}
